<!DOCTYPE html> 
<html><!-- InstanceBegin template="/Templates/page.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<link rel="stylesheet" href="../../../../../Stylesheets/prettify.css" />
<link rel="stylesheet" href="../../../../../Stylesheets/pageStylesheet.css" />
<link rel="stylesheet" href="../../../../../Stylesheets/navigationStylesheet.css" />
<link rel="stylesheet" href="../../../../../Stylesheets/allTextStyles.css" />
<link rel="stylesheet" href="../../../../../Stylesheets/colors-blue.css" />

<script type="text/javascript" src="../../../../../Scripts/google-code-prettify/run_prettify.js"></script>
<script type="text/javascript" src="../../../../../Scripts/recomputeAttributes.js"></script>


<!-- InstanceBeginEditable name="doctitle" -->
<title>Project</title>
<!-- InstanceEndEditable -->
</head>

<body id="body-style">

<!-- 
<div id="browser-window-veil">
</div>
-->

<div id="page-container">

<header id="header">
<div id="track-icon1">
  <img src="../../../../../Media/StyleImages/bobcat-small.png" alt="bobcat icon" width="75" height="48"></div>
<div id="track-icon2">
</div>
<div id="track-icon3">
</div>
  <div id="headMatter">
    <span id="headTitle1">
      <!-- InstanceBeginEditable name="Header" -->
        Team 8
	  <!-- InstanceEndEditable --> 
    </span>
    <span id="headTitle2">
    </span>
  </div>
</header>

<nav id="navigate">
</nav>


<aside id="aside-left">
<div id="asideLeftTitle">
Compilers 2014
</div>

</aside>

<aside id="aside-right">
</aside>

<footer id="footer">
  <div id="footMatter">
    <span id="previousPageLink">

    </span>
    <span id="currentPageNumber">
    </span>
    <span id="nextPageLink">

    </span>
  </div>
</footer>

<article id="mainContent">
<!-- InstanceBeginEditable name="Main" -->
<h1>Parser Commentary</h1>
<h3 class="centered">By Stephen Bush</h3>
<h2>Purpose of the Parser</h2>
<p>The parser is meant to derive meaning from the order of the tokens determined by the scanner.</p>
<h2>Theory Behind Parsing</h2>
<p>A parser for a context-free grammar can be designed and implemented directly from its EBNF grammar.  Because the grammar is context-free, that allows for certain assumptions which enable a recursive descent method of parsing.  For example, the parsing of any non-terminal at any given point is not dependent on anything parsed previously, only on its current lookahead token.  That allows for each non-terminal to be delegated to its own procedure call, dedicated to handling that non-terminal and all of its grammar rules.</p>
<p>If this procedure encounters a terminal in one of its rules, it can <b>match</b> that terminal.  That is, it can determine if the lookahead token has a type which is the same as it was expecting to find in the current rule.  If so, it asks for the next lookahead token and continues its evaluation.  If one of those rules should need to deal with an additional non-terminal, this procedure can recursively call the procedure dedicated to handling <i>that</i> non-terminal, and so on.</p>
<h2>Example</h2>
<h3>Context-Free Grammar Rules for Selected Nonterminal</h3>
<pre>99	Factor	→  UnsignedInteger
100		→  UnsignedFloat
101		→  StringLiteral
102		→  "True"
103		→  "False"
104		→  "not" Factor
105		→  "("Expression ")"
106		→  FunctionIdentifier OptionalActualParameterList</pre>
<h3>LL(1) Table</h3>
<p>In order to create these procedures for the non-terminal rules, we can use its LL(1) table.  A LL(1) table is a table generated by crossing a grammars terminals and its non-terminals, and at the cells of intersection, examining the given non-terminal and deciding which of its rules should be executed when the given lookahead token is encountered.  Once all the non-terminals have been evaluated and the table has been completed, any cell which remains empty represents a syntax error.  That is, the grammar does not permit the given token to legally be matched with the current non-terminal.  Additionally, any cell which has multiple rule numbers listed in it represents a conflict, or an ambiguity in the grammar.  Often these conflicts can be resolved by altering the grammar, increasing the number of lookahead tokens, or adjusting the semantic analyzer.</p>
<p>The following example defines the LL(1) table for the Factor non-terminal described above, selected from the micro-pascal grammar.  For space conservation, empty cells are ommited.</p>
<p><table border=1>
<tr align="center"><td></td><td>&nbsp;&nbsp;MP_FALSE&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;MP_NOT&nbsp;&nbsp;</td><td>&nbsp;&nbsp;MP_TRUE&nbsp;&nbsp;</td><td>&nbsp;&nbsp;MP_IDENTIFIER&nbsp;&nbsp;</td><td>&nbsp;&nbsp;MP_INTEGER_LIT&nbsp;&nbsp;</td><td>&nbsp;&nbsp;MP_FLOAT_LIT&nbsp;&nbsp;</td><td>&nbsp;&nbsp;MP_STRING_LIT&nbsp;&nbsp;</td><td>&nbsp;&nbsp;MP_LPAREN&nbsp;&nbsp;</td></tr>
<tr align="center"><td>Factor</td><td>103</td><td>104</td><td>102</td><td>106</td><td>99</td><td>100</td><td>101</td><td>105</td></tr>
</table></p>
<h3>Rule Expansion</h3>
<p>The basic procedures for each non-terminal can be generated directly from the LL(1) grammar table.  In fact, there are algorithms for doing so and generating the code automatically.  These base procedures can later be augmented further with semantics analysis code for generating the final assembly code.  Examine the elements of the following example:</p>
<p><pre class="prettyprint"><code class="language-java">
    public static void factor() {
        switch (Lookahead) {
            case "MP_INTEGER_LIT": // Rule #99
                match("MP_INTEGER_LIT");
                semAn.pushCheck(lastTok, symTab);//pushes the value onto the stack
                litOrVar = "literal";
                break;
            case "MP_FLOAT_LIT": // Rule #100
                match("MP_FLOAT_LIT");
                semAn.pushCheck(lastTok, symTab);
                litOrVar = "literal";
                break;
            case "MP_FIXED_LIT": // Rule #100
                match("MP_FIXED_LIT");
                semAn.pushCheck(lastTok, symTab);
                litOrVar = "literal";
                break;
            case "MP_STRING_LIT": // Rule #101
                match("MP_STRING_LIT");
                semAn.pushCheck(lastTok, symTab);
                litOrVar = "literal";
                break;
            case "MP_TRUE": // Rule #102
                match("MP_TRUE");
                semAn.pushCheck(lastTok, symTab);
                litOrVar = "literal";
                break;
            case "MP_FALSE": // Rule #103
                match("MP_FALSE");
                semAn.pushCheck(lastTok, symTab);
                litOrVar = "literal";
                break;
            case "MP_NOT": // Rule #104
                match("MP_NOT");
                Token not = lastTok;
                factor();
                semAn.pushCheck(not, symTab);
                litOrVar = "literal";
                break;
            case "MP_LPAREN": // Rule #105
                match("MP_LPAREN");
                expression();
                match("MP_RPAREN");
                litOrVar = "literal";
                break;
            case "MP_IDENTIFIER": // Rule #106
                functionIdentifier();
                Token identifier = lastTok;
                Row funcOrVar = symTab.findVariable(lastID);//we need to know if the id we grabbed is for a variable or for a function call
                
                if(funcOrVar == null)syntaxError();//if it doesn't come back right, the identifier isn't in a symbol table
                
                if(funcOrVar.getKind().equals("function")){//if it's function call
                	semAn.pushRoomForRetVal(funcOrVar.getType());//makes room in the stack, as well as saves the type of the stack before this call is made
                	String oldParams = paramTypeList;//store the old parameters list in case function call is used as parameter type
                	String oldLitVar = litVarList;
                	paramTypeList = litVarList = "";//reset the list
                	optionalActualParameterList();//fill the list
                	//make the calls and check that the parameters given fit what is needed
                	semAn.functionProcedureCall(paramTypeList, litVarList, symTab, identifier);
                	paramTypeList = oldParams;//restore the old list
                	litVarList = oldLitVar;
                    litOrVar = "literal";
                }
                else if(funcOrVar.getKind().equals("retVar")){//if it's a recursive function call, the type that will come back is the returnVariable type
                	semAn.pushRoomForRetVal(funcOrVar.getType());
                	String oldParams = paramTypeList;
                	String oldLitVar = litVarList;
                	paramTypeList = litVarList = "";//reset the list
                	optionalActualParameterList();
                	semAn.functionProcedureCall(paramTypeList, litVarList, symTab.getParent(), identifier);
                	paramTypeList = oldParams;
                	litVarList = oldLitVar;
                    litOrVar = "literal";
                }
                else{// if the identifier is just a normal variable
                	semAn.pushCheck(identifier, symTab);
                }
                break;
            default:
                syntaxError();
                break;
        }
    }
</code></pre></p>
<p>The basic structure of each procedure consists of a switch statement which jumps based on the current lookahead token.  As you can see, the different case labels for the switch statement are made up of the terminals taken directly from the LL(1) table, with the default case reserved to catch the remaining token cases which correspond to empty cells in the table which, if we remember, represent syntax errors.  The body of the switch statement consists of the grammar rules themselves, in the form of match() calls and non-terminal procedure calls.</p>
<p>Additionally, this example contains an extensive amount of semantic analysis code.  In addition to just validating the syntax, the parser uses a semantic analyzer to re-order and straighten out the final compiled code while the parser runs.</p>
<!-- InstanceEndEditable -->


</article>
</div>
</body>
<!-- InstanceEnd --></html>
