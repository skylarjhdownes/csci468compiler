program ID;
   
   function ID( ID, ID: boolean): integer;
      
      begin
         
      end;
   
   function ID: string;
      
      begin
          for ID:= "STRING"> not(- "STRING" mod true) downto+( 42) do;
         ;
          writeln(- false< ID)
      end;
   
   function ID: float;
      
      begin
          repeat if not 42 then for ID:=+ "STRING" or 3.14159 or false downto ID do if+ 42 or false<= "STRING"+ "STRING" then
         begin
             writeln( not((- false)<> true));
            ;
             repeat;
             writeln( 42 or "STRING" mod false+ not not( ID(- "STRING"))- true mod not( ID), 3.14159 or 42+( ID)>= 42, ID);
             repeat;
             while "STRING" or false< false do while ID do for ID:= true>= "STRING"* 42 to( 42) div ID do;
             read( ID);
             ID;
            ;
            ;
             write(+(+ not "STRING"),+ 42>= not not not false, not 3.14159/ ID>=+(- 42) and not(- false>(+( false>+ "STRING"- not "STRING"+ 3.14159))) div "STRING");
             ID;
             for ID:=+ true* 42+ false* true=+ true to "STRING"+( true)+ true mod ID do;
             write( not 3.14159<+ 3.14159+ "STRING", "STRING");
            ;
             if not ID(+ "STRING")>= 42 div 42 then;
            ;
             while not(+ "STRING") do write( ID, 42, 3.14159/ "STRING") until 42- true;
            ;
            ;
            ;
            ;
             until "STRING"<= false;
             repeat;
             writeln( "STRING");
             ID;
            ;
            ;
             ID;
             writeln(+ 3.14159* true< 42* 42, 42, ID div( true<= ID)+ "STRING"<= false,( true) div ID);
            ;
            ;
            ;
            ;
             while "STRING" div(- 42) do ID;
             for ID:=( true and 42 div(( 42>= 3.14159) div 3.14159)) to( "STRING" mod( true)) do;
             write(+ "STRING" and not not "STRING"<> "STRING", not ID, true* "STRING");
            ;
             writeln( not "STRING"> 3.14159, 3.14159 or( 3.14159 mod 3.14159) div true/ false> true or true, 3.14159,- 42>- ID);
             if "STRING" div not false or 42< "STRING" mod(+ "STRING" div 42) then else;
             ID;
            ;
            ;
             ID;
             read( ID) until not false- true and(( ID)+ false);
            ;
             writeln(( 42<( ID) and ID+ "STRING")/ ID, not not "STRING" or not 3.14159);
            ;
             for ID:=- false+ not true and true<=+( ID) downto- false do while( "STRING"<- ID* not true/ "STRING"+ true) do;
            ;
             write( 42, "STRING"= true, true> ID);
            ;
             if- not not ID then repeat;
            ;
            ;
            ;
             repeat;
            ;
             while+ false or ID do for ID:= ID( 3.14159- 3.14159 mod 3.14159<> "STRING") downto not ID do read( ID, ID) until true/ false> true until true*(( 3.14159<= "STRING") mod true);
             if true or true then repeat write( not 3.14159<= false* not 3.14159* not 42,( ID));
            ;
             until ID* false+( false<=+( true-(- false=- 3.14159))/ 42)<- false;
             if- 42+ not 42/ not ID then while true do else read( ID);
             while+ ID( 42, false<- false) do;
             for ID:= "STRING">= 42 downto 42- "STRING" do
         end else;
          writeln(+ "STRING", 3.14159);
          write(- ID,+ false);
          if "STRING" then else;
          read( ID);
         ;
         ;
         ;
          if- not 42<> not false mod not 3.14159 then while "STRING" do writeln( ID and ID/ "STRING"<> 3.14159) else;
          read( ID);
          read( ID);
          ID;
          for ID:=( true mod not false)< ID downto false=( 3.14159 or 3.14159 div "STRING") or ID do ID;
         ;
          repeat for ID:=( false and true>=- ID) to 3.14159 or 42 do;
          writeln((- ID+ 3.14159<> 3.14159* "STRING"), 42 mod 42, 3.14159,+ not "STRING">- 3.14159,- false>= false+( true- 42), "STRING", ID<= "STRING" and 42 and 42);
          write( 42 or true>=( "STRING">=( 3.14159)),+ ID or not ID<=+ not ID* false) until 3.14159>= ID;
          for ID:= true=+ not ID downto not "STRING"* not true- not 3.14159 do;
          while not true and 3.14159<= not ID do;
          until- "STRING" mod not 3.14159 and 42;
          ID;
          if true+ ID<= false then writeln( false mod 42);
          ID;
         ;
          repeat read( ID) until+( "STRING" or ID( "STRING"= true div( false)/ true)> "STRING" div true)= false;
          for ID:=( true mod true)<=(+ true<= 42) mod false and(+ not true>=( not "STRING"/ "STRING")) downto not( false) do;
          repeat if 3.14159 then ID(- true=- true, true and "STRING"<> true,( not 42* not true)>= 3.14159);
          read( ID, ID);
          write( ID- ID);
         ;
          writeln(+ not not 3.14159<> "STRING",+ ID and ID);
         ;
         ;
          writeln(- false or(+ 42< false)* ID<=+ 42, not 3.14159* ID= "STRING") until "STRING"<= false;
          writeln( "STRING", true);
          write(((-( not 3.14159<> true mod 3.14159 mod 42- 42))+ 42)> 42/ ID)
      end;
   
   function ID: float;
      
      procedure ID;
          var ID: string;
         
         procedure ID;
            
            begin
                write( not true>- true- true/ 42);
               
            end;
         
         procedure ID( var ID, ID: integer;
             ID, ID: float;
             ID, ID, ID, ID: boolean;
             ID: boolean);
             var ID, ID, ID: string;
            
            begin
                while 3.14159 div "STRING"< not( false= false or( true= ID mod false* ID)) do ID;
               
            end;
         
         begin
             if ID then;
             for ID:=- false div ID+ 3.14159 to 3.14159 do repeat while+ 42>= "STRING"+ true do;
             while( true) mod "STRING">= 3.14159 do ID until 3.14159>= 3.14159;
            ;
             write( 3.14159);
             ID;
             repeat if true then repeat if- false then while 3.14159> not ID do read( ID);
            ;
             for ID:= "STRING" downto not not 42>= false do while 3.14159<>+ true do ID until- true or(+ ID) or true;
            ;
            ;
            ;
             read( ID, ID);
            ;
            ;
             repeat;
             read( ID, ID);
             repeat;
            ;
             for ID:= true+ ID to 3.14159< 42 do while(- 3.14159/ ID) do ID;
            ;
            ;
             repeat if( ID<+ not( false+ 42 mod not false)) then write(( false* 3.14159/ "STRING"* not ID* ID)<(+ ID), "STRING"<= "STRING", 42* "STRING"= 42);
             read( ID, ID, ID);
             until not false/ 3.14159 until false<> 42- "STRING";
             write(( 42= 3.14159));
            ;
             read( ID, ID);
            ;
             while not "STRING" do writeln( false, "STRING"< ID, not 42);
             writeln(( ID- false< "STRING") and not ID);
             until+ 42+ 42<=+ 42* false until not not false;
            ;
            
         end;
      
      procedure ID;
         
         begin
             while- false do ID;
             write( "STRING");
             repeat;
             write( true mod 3.14159<> 42);
             if 42/ ID then;
             if false< "STRING" then writeln( false= "STRING", "STRING"=+ true);
             if false then write( ID>= true,( "STRING"+ true<= "STRING" or 3.14159)/ true or ID< not 3.14159, ID<> "STRING",( 3.14159* 3.14159>+ 3.14159), 3.14159<>(+((+ true= true)>( true and "STRING"< 42/ "STRING" div true) div not( 3.14159> not not( not ID- 3.14159 and ID( false> "STRING"+ ID, ID/ false* 3.14159) mod false)/( "STRING"- ID)))));
             write(- 3.14159, not( true));
             for ID:=(+ 42) to ID>- not true- true do if "STRING" then;
             write( "STRING", "STRING", 42);
            ;
             if ID or not true then until true+ "STRING" or 3.14159> "STRING";
            ;
             write( ID( true mod( 42), 3.14159/ not ID- 42<=( 42),- false or 42< false and ID)- false)
         end;
      
      procedure ID;
         
         begin
             ID;
            ;
            ;
             read( ID)
         end;
      
      begin
          ID;
         ;
          while true mod 42 do;
          for ID:=+ not true<= true downto 3.14159- false do read( ID)
      end;
   
   procedure ID;
      
      begin
          writeln( true,- 42+ "STRING"> ID);
         ;
         ;
          repeat;
         ;
          write( true and 3.14159 and true,+ not ID,( ID( "STRING" and 3.14159, false div not( "STRING")=-( false/ not 42*( false mod ID)) div 3.14159,- 3.14159, "STRING" mod false, "STRING"- 3.14159, false/( false/ not not true< not 42) and true) or( "STRING" div "STRING")/ 42>= 3.14159)+ "STRING" and "STRING"<=+ false+ false- false) until true;
          while false+ 3.14159- true do ID;
         ;
          repeat for ID:= true downto not "STRING" do read( ID, ID, ID, ID, ID, ID) until true>= 42;
          writeln(( false)>= 42, "STRING",( 3.14159 and false<>(+ "STRING")) div( false< "STRING"- true) and false and(+ not true));
         ;
         ;
          while 3.14159 do
      end;
   
   begin
       write((( ID+ false)), false, not 3.14159<=( true div false+ false));
       writeln( ID);
       read( ID, ID, ID, ID, ID);
       if false then if- "STRING" then if not false then repeat for ID:= "STRING"= true* 42 or "STRING" or 42 downto false do for ID:=+ not 3.14159- ID downto false=+ 3.14159 do;
      ;
       writeln(- true, 42* "STRING"<=+ 42);
       writeln(( 42),( ID), ID, not "STRING"<> 42 and( 42), true,+ ID, 42, true<> not true/( not 42<( true)), false, false);
       repeat repeat repeat;
      ;
       for ID:=( false=+ 3.14159 or false)- not false to true do;
      ;
      ;
      ;
       write( ID);
       read( ID) until-( not 3.14159/ true or true mod false)< 3.14159;
      ;
       for ID:=- not true and false<= true to- ID do until( "STRING">= false)>= "STRING";
       repeat writeln(- false, 3.14159>= true/ ID);
       read( ID);
       repeat while true do ID;
      ;
       repeat;
       repeat;
       write( 3.14159<=+( "STRING"), false/ "STRING");
       until( "STRING") mod ID and 42;
       writeln( false or(+ true> "STRING"/ not ID)<>(( ID)> not((+ false)/ false)+ 42) div "STRING", false=+ true* false, not false);
       writeln(- 42);
       for ID:= true to true do ID(- 42, 3.14159);
       while((( 42>= 42 mod 3.14159* 3.14159)+ ID)) and ID do until ID;
       ID;
      ;
      ;
       while "STRING"<=+ ID do;
       writeln(+ true<= 3.14159- not false mod 42);
       until not ID or false and false;
      ;
       if "STRING" then writeln( not 3.14159=- ID+ 3.14159, 3.14159) else;
      ;
       ID;
       read( ID, ID, ID, ID, ID, ID);
       read( ID);
      ;
       while- "STRING" mod false do read( ID, ID, ID);
      ;
       read( ID);
       while- true* true div ID do while 42= false do writeln( 42);
       if true* true then writeln( not ID= ID);
       write( "STRING") until "STRING"<> "STRING";
       repeat;
       repeat while- ID/ "STRING" do read( ID) until ID and false;
       repeat;
       repeat repeat writeln(( ID<>(+ ID= not ID))/ "STRING">= 3.14159+ "STRING",- not(- 42<= not ID( not 3.14159> 3.14159, "STRING"= true* true))<> true);
       ID;
       ID(- "STRING"/ not not( ID and "STRING">= "STRING")/ ID< true);
       write(+ 3.14159);
       while false do write(+ false);
      ;
      ;
       ID;
       read( ID);
      ;
      ;
       ID;
       for ID:= not not(( false>( 42))>= "STRING") or not false< not "STRING" downto true and true do write(- false div not false- 3.14159 and false) until true<>+ not not "STRING";
       read( ID) until 3.14159 or( false);
       ID;
       for ID:=- true to not not 42= 42 do read( ID, ID, ID, ID) until( ID mod "STRING">= false) and "STRING" and ID;
       until "STRING" until- 42 mod "STRING" mod not "STRING";
      ;
       repeat repeat;
       read( ID);
       if 42 then while( 3.14159) do until ID;
       while+ 3.14159- true or false do repeat;
       read( ID, ID) until( false and false mod not not 42>= 42)+ "STRING"< true;
      ;
       write(- false> not ID( not false or ID+ ID and not true= 42, "STRING" and false,+ 3.14159<( "STRING"- true)/ not false div 42, "STRING"<= 3.14159, false,+ true) mod ID, not 42- true, 42 mod 3.14159>= true);
      ;
       writeln( 3.14159 and( not true/( true- "STRING"/ "STRING"=- "STRING" mod 42 mod 3.14159- false) and ID( 3.14159)), 3.14159+ ID);
      ;
       writeln(- 3.14159= ID mod 3.14159);
      ;
       repeat;
       repeat if- 3.14159<= 3.14159 then else until "STRING"- not 42 or false;
       write( false,( not 42 div true),( "STRING"*( not 3.14159+ not 42+ not not true* ID<= 3.14159+( "STRING") and not not "STRING" or not( false<=+ not true- 3.14159))<> 3.14159)* true, 42,- true);
      ;
      ;
       until 3.14159;
       write(- ID>=( not false> ID));
       for ID:= ID< "STRING" downto(( ID- 3.14159) or "STRING") do write( ID, true);
      ;
       for ID:= "STRING"<= true downto false do;
       while not 42 do write( 42 mod ID);
       ID;
       for ID:= 3.14159<>+ true downto true+( 42>=- 42) or(- 42< 42 mod not(- not not "STRING"))* 3.14159 do;
       for ID:=-( ID=- ID)>= 42 to "STRING" or 3.14159* false do;
      ;
       if 42+ 42/ not "STRING" mod false* "STRING"<> false mod false div true+ "STRING"/ "STRING" and ID then;
       for ID:= not "STRING"<> not ID downto "STRING" mod "STRING" do;
       writeln( ID, 42= 3.14159,+ 3.14159> not 42);
       while 3.14159+ true do;
       write(- "STRING", 42 mod "STRING", "STRING"<> "STRING");
       if true then writeln( 42,(+ "STRING")>( not 42) mod(- 42- ID mod( ID)* not "STRING" mod( not false>= not true+ not ID)<> not false* not not false));
       write( 3.14159);
      ;
       read( ID, ID) until- 3.14159> true- 42;
      ;
       write( not "STRING"<= true or "STRING" mod 3.14159 div true);
       read( ID, ID) until not 42< 42
   end.