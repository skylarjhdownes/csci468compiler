program ID;
   
   function ID: float;
      
      begin
         ;
          while- 42* 3.14159* 42/ 'STRING' do;
         ;
          writeln( not 'STRING');
         
      end;
   
   function ID: boolean;
      
      procedure ID;
          var ID, ID: string;
         
         begin
             if true then ID;
            ;
            
            begin
               ;
               ;
               ;
                read( ID, ID);
                writeln(- ID/ 3.14159* not 'STRING'<( 'STRING'/ false));
                while(- 'STRING' div true)/(-(+ 3.14159)<= 42 or 3.14159) do ID
            end;
             ID;
            ;
            
            begin
                ID( 3.14159);
                repeat;
               ;
               ;
                repeat;
               ;
                for ID:= 3.14159 downto 'STRING'= 42 do write( 'STRING' and true,- true>= not( 3.14159 and 'STRING'));
                while(+ true<> not( true/ not true)) do write( 42);
               ;
                repeat while ID div 'STRING'> false do until true;
                while 3.14159<=( true* 'STRING'/ 'STRING'>= 'STRING') do ID until ID>=+ true;
                if+(( 3.14159>= false)) then if ID then for ID:= 'STRING' and ID and not true to+ 42/ 42 do writeln( 'STRING'<= ID) else while ID do for ID:= 42 downto 42> false do else write( true or 3.14159, true= 'STRING', 'STRING'* true and 3.14159< false div( 'STRING') div not not false);
               ;
               ;
               ;
                repeat until 42>= ID until 42;
               ;
                ID;
               
            end;
            ;
            ;
             read( ID);
            ;
             write( 3.14159* 3.14159);
            ;
            
            begin
               ;
               
               begin
                   ID;
                   write(- not( false) mod 42<= 'STRING',( true+ 42* 3.14159<> true)> 42, false and ID<= true div 'STRING' mod 'STRING');
                  ;
                  
               end;
                while 42 do ID;
                write((- 42- 'STRING'), false>=(+ true- not 3.14159< 'STRING' div 3.14159));
               ;
                read( ID);
                ID;
                for ID:= true downto 3.14159 and( not ID- false)>- false do write( true or 3.14159>+ 'STRING', true div not 'STRING'* true, ID);
               
               begin
                   write( 'STRING'* false> true);
                  ;
                  ;
                  ;
                   if ID+ false< not 42 then;
                   read( ID)
               end
            end;
            ;
            
            begin
               
               begin
                   if- 3.14159= ID then while false do;
                  ;
                   for ID:= 3.14159 or ID to- 42>=( not 42/ 3.14159) do ID;
                  
               end;
               ;
                for ID:= 'STRING' to 3.14159- true do write( false)
            end;
             writeln(+ 'STRING'/ ID+ 3.14159 div ID)
         end;
      
      begin
         ;
          writeln((( not ID)));
          while(( 3.14159) or 'STRING'*( not((( 'STRING') div not(+ false< false))<=+ true+ not true)))* 42= true do;
          if not ID>= 'STRING' then else repeat writeln( 'STRING' and((+ false)<( 42))<= false);
         
         begin
            
         end;
          read( ID, ID, ID);
          writeln(- 'STRING');
          read( ID);
          for ID:= false and false mod 'STRING' div 'STRING'>( false- 42 div 42 or 3.14159< 42) mod 42 to false>( ID* 42 or 3.14159) do;
          if+ true div ID then write( 42=( not false or 42<>- false and true));
         
         begin
             if 3.14159 mod 3.14159 then;
             ID
         end;
          for ID:= ID- 42 mod( 42) mod 'STRING'=- false downto 3.14159*( true)< false do write( 'STRING', 42- ID, 'STRING'- 42=- false,+ 3.14159,- 42<( true< 42));
          while(+ false- not 3.14159/(( true) div true+ 3.14159<>+ not 'STRING')) do write((+ ID= ID),(( 'STRING'<> false)/ not 'STRING'>= 'STRING'));
          repeat if not 42 mod 3.14159* 'STRING'<> 3.14159/ ID mod not 3.14159 then while- true do;
          repeat write( not true+ 'STRING');
          write( 'STRING'- 3.14159 div 42<> false+((+ 'STRING')) and false);
         ;
         ;
          if+( 'STRING' or 3.14159 or 3.14159>= 42) div 3.14159+ 42 then else if 3.14159 then ID;
          for ID:= not not 'STRING' to true<> false mod not 42 do writeln( 'STRING' mod ID);
          ID;
         ;
         ;
          repeat;
          if 3.14159> ID div false then;
         ;
          read( ID);
          while 42 do ID;
          ID;
         ;
          write( 'STRING'/ 3.14159>= 3.14159, false, true, 'STRING' and true<> true div true);
          write( false, false/ true,- ID, false and( ID* 'STRING'+ not true)<> 3.14159/ not 'STRING',+ ID, true=(- 'STRING'));
          for ID:= ID< true*( 3.14159) to- false*((+( 3.14159))>=- 'STRING') or true do
         begin
            ;
             for ID:= not ID+ 'STRING' downto- 'STRING'= 3.14159 do;
             read( ID);
             for ID:= ID* 'STRING'>= true to not( 42)>= true do repeat read( ID, ID);
             read( ID, ID) until 3.14159;
             write( not 'STRING' div 'STRING'/ true div 'STRING'/ 3.14159, 'STRING',( true))
         end until false until((+ 'STRING'<>+ false)>+ false);
         ;
          while 'STRING'<=( 3.14159* 'STRING'> 42) do if ID then;
          repeat for ID:= 42 to 3.14159+ 3.14159 and false<= 3.14159 do;
          if 'STRING' and true mod false then read( ID, ID) else for ID:= not 42<> not false downto( true or not 42) do;
          writeln( not false<> 3.14159) until 'STRING'+ not ID+ false<> 'STRING';
          read( ID) until 3.14159> not true;
         ;
         ;
          for ID:= 42= not true mod 'STRING' to 'STRING'=- ID do ID;
          writeln(+ 'STRING' and 3.14159 and 3.14159, 'STRING', not not 3.14159);
          read( ID);
          write( false* 3.14159 or( 42) mod(- false<(+ not true= ID or 'STRING' or true or not 42 and 'STRING'+ ID/ ID* 3.14159)) div not 42);
          write( 3.14159<>(( 'STRING'<= ID)>= 3.14159),( true) and 42<>- 'STRING');
          while false+ 'STRING'<= ID do;
         ;
          for ID:= 'STRING'>= true to(+( not 3.14159>- false) mod true) do repeat;
          while(+ true* 'STRING' or( true mod not false)<> 'STRING' div not false* 3.14159 or 42) do;
         ;
         
         begin
             if ID then;
             for ID:= 3.14159 downto 'STRING'> not 3.14159 do writeln( 42>= ID div false);
             while- 'STRING'<= ID do for ID:= false downto false> 'STRING' and(( not( ID/ 42)< ID mod 'STRING' or not false* 3.14159) div ID) do;
            ;
             read( ID, ID);
             write( ID);
             for ID:= true and 3.14159 to 3.14159 do while not false do
            begin
                writeln(+ false);
                while 42>= not true/ 42 do repeat read( ID, ID, ID, ID) until 3.14159= false;
               ;
               
               begin
                   while 'STRING'> not ID+ 3.14159 div false do;
                   read( ID);
                   if-( 3.14159>= true) div( true- 'STRING')<=- ID and 'STRING' then;
                   for ID:= not false and 'STRING' downto 42 do
                  begin
                     
                  end;
                  ;
                   read( ID);
                  
                  begin
                      write( 'STRING'> 'STRING', false- 3.14159 or 42, ID> false, 3.14159 or 3.14159, 42* 'STRING',- ID= 42- ID, 'STRING'+ ID* ID, 3.14159);
                     ;
                      write(+ 3.14159);
                     ;
                     
                  end;
                  ;
                   for ID:= 3.14159< 'STRING' or 42 or ID- 42 to 'STRING' or ID/ not 3.14159 or not not( 3.14159 and 3.14159=- false and 'STRING')<>- true and((- true>=( not ID* not 3.14159+ 'STRING' and 42)) or true= true) do writeln( 3.14159);
                   ID
               end;
               
               begin
                   read( ID);
                   if 'STRING' and false then write( 42 mod( 42>=(- true- 3.14159 mod 42)));
                  ;
                   write( false mod 'STRING'* 3.14159)
               end;
                write(( not 'STRING'),- true);
               ;
                ID
            end
         end;
         ;
         ;
         
         begin
            ;
             if+ false then else write( false)
         end;
         ;
          while+ 'STRING'/ not false or not( ID)<= 'STRING' div false do for ID:= 42<= 3.14159 downto 42- 'STRING'=( 42/ not ID)- 3.14159 do;
         ;
         ;
         ;
          until ID= 3.14159 div 42 until ID and false/( 3.14159) div false;
         
      end;
   
   function ID: boolean;
      
      procedure ID( ID, ID: boolean);
          var ID, ID: string;
         
         procedure ID;
             var ID: boolean;
            
            begin
               ;
               
            end;
         
         procedure ID;
            
            function ID: string;
                var ID, ID: string;
               
               procedure ID;
                  
                  procedure ID( ID: boolean);
                     
                     begin
                        
                     end;
                  
                  function ID: string;
                      var ID: string;
                     
                     begin
                         for ID:=-( false)+ false/ 42=-( 42) downto not true>=( 'STRING'/ false- true) do read( ID)
                     end;
                  
                  begin
                      if- ID- not( false) then while( false div 'STRING')<=- not 42 do for ID:= not true and true=( ID/( 'STRING'> not not false) or ID) downto true mod 3.14159 and true do;
                      while 42< 'STRING' div false mod false do writeln( 'STRING'= not not(+ true) or ID)
                  end;
               
               begin
                   writeln( true);
                   while( not true div 42) do if+ not 'STRING' then ID;
                  
                  begin
                     ;
                      if 3.14159 then read( ID) else while( 42* ID div not not true) do;
                     ;
                     ;
                      writeln( not ID>=- not 3.14159 mod false- ID);
                      writeln( not 'STRING' or true<= 'STRING');
                      while(+ 3.14159< true+ 'STRING') or ID/ not 42 do;
                      read( ID);
                      while false do;
                      if not 3.14159/ 42 and 'STRING' or not 'STRING' then else writeln( 42,+ ID and not ID>= ID,- 'STRING');
                      while false do;
                      if 42> true then else ID
                  end;
                  ;
                   repeat repeat ID;
                  
                  begin
                      read( ID)
                  end;
                   while 'STRING'< 'STRING' do repeat while(( not not true<= true) mod ID and 42>= ID)/ 3.14159 do writeln(- true= not( false)) until 42;
                   write( 'STRING'<=+( false= not(+ 3.14159+ 3.14159) div true), 42<- false- not false) until ID;
                  ;
                  ;
                   while 'STRING' mod false> ID-( ID<>( 3.14159* not 42)) do while 'STRING'>=-( not true)*( 3.14159<> false/ not not ID/ not false)* not 3.14159 do;
                   if ID<> false then while 42 do write( false<> 'STRING', 3.14159, false<>+ 'STRING'- true, false) else ID;
                   until 3.14159 div 'STRING'/ 3.14159<= 'STRING'*( true)* 3.14159;
                  
                  begin
                      while 42<> 'STRING' do writeln( not not 3.14159- 42 or true<> true, true= 3.14159 mod 3.14159)
                  end;
                   while+ 3.14159> 3.14159 do repeat
                  begin
                     ;
                     ;
                      writeln( 3.14159 or not 3.14159+ 42=+ 3.14159);
                      ID;
                     ;
                      ID;
                      for ID:= true to 'STRING' do;
                      writeln( 42= 3.14159+ 'STRING', 'STRING'/ not not 3.14159, 3.14159, not not 3.14159,- true= not 42 mod 'STRING');
                      repeat while 3.14159 do ID;
                     ;
                      ID;
                      if not ID+ ID* true<= 42 mod 'STRING' then write( false* 3.14159 and false*( 'STRING'= 'STRING') or 42) else ID(( ID) or ID>= 3.14159);
                      read( ID) until 3.14159<= ID div not not ID;
                      writeln( ID, ID>= 3.14159 and 42);
                     ;
                      write( false> 'STRING', 42 and 3.14159)
                  end;
                   repeat ID;
                   for ID:= true to true or 'STRING' do
                  begin
                     
                  end;
                  ;
                   writeln( 3.14159);
                   while 'STRING'<- 'STRING'/ 42 do;
                   read( ID, ID);
                   while not 3.14159 do write( 'STRING'- 'STRING'* false- ID and false+ 42 and( 42> not( not ID))+ 3.14159= 3.14159) until 3.14159=+ not false mod ID;
                   ID;
                  
                  begin
                      write( 42 or( 3.14159<> 'STRING'- ID or ID and false+(- 42* true and((+ true)) mod( ID)>= not 3.14159)+ 3.14159 div not not false* ID)+ 42* 'STRING', 3.14159);
                      write(( 'STRING'< not false)<= not true,+ 'STRING');
                      for ID:= not 'STRING' to+ true* 'STRING'= true do
                  end;
                   repeat read( ID, ID, ID);
                   write( 42> true) until not( ID and false div 3.14159) div 42;
                  ;
                   until( 'STRING'- 3.14159);
                   write(-((+ 42) or 42)/(+( false) mod false> false));
                   writeln(( 'STRING')* false-(( 3.14159 or true<> ID)), 3.14159< ID);
                   for ID:= false downto true do for ID:= false to 3.14159 and 3.14159 do writeln((- true<+ ID/ 42)<> false,+( ID div( 3.14159>= false)< ID)<= 'STRING', 3.14159);
                   read( ID);
                  
                  begin
                      if+ false= not not 'STRING' then;
                      repeat;
                      while true<=+(-(- 42 mod not( not not false mod true) and 'STRING') div( 'STRING')) do if+ not ID= false then until 'STRING';
                     ;
                      while 42<> not 42 mod ID do;
                     ;
                      read( ID);
                     ;
                     ;
                      write( 42);
                      for ID:=-( 42) downto ID<>- true+ ID do if 42 then else ID
                  end;
                  ;
                  
               end;
            
            begin
               
               begin
                  
                  begin
                      for ID:= 3.14159= 'STRING' div(( not 'STRING') mod 42>= not 'STRING') downto true do read( ID, ID);
                     ;
                      while 3.14159/ true- false/( not not false> false/ ID)<> true do for ID:= 42 mod ID and ID downto- ID<=( false) do for ID:=- false>= 3.14159 to+ 'STRING'= 42 div false do repeat until+ 3.14159<= 3.14159;
                      ID;
                      ID
                  end;
                   read( ID);
                   read( ID);
                  ;
                   repeat ID;
                  ;
                   read( ID, ID);
                  
                  begin
                      writeln( true);
                     
                  end until ID
               end;
                writeln( 3.14159, 'STRING');
                write(+ true+ true, 3.14159);
               
               begin
                  
                  begin
                      if false>+ 42 then writeln( not 'STRING') else ID;
                      while+( 'STRING'<>+ not 42 and(- true mod( false* 42 div 'STRING')>( 'STRING'= 3.14159)+ 42 or 3.14159 and false)) mod not 42 and true=- not( ID>= ID) do for ID:=-(- not 'STRING') downto 'STRING'<> 'STRING' do for ID:=- ID to( 42)*(- true)<=( not true) do ID;
                     ;
                      writeln(( 42= not not ID), 42 mod not false div ID);
                     
                  end;
                   repeat;
                  ;
                   repeat
                  begin
                      repeat while 3.14159+( ID div true* 3.14159 and not false<> false or ID*( 3.14159 or not false div 'STRING'- false))*( true* 3.14159) do ID;
                      read( ID, ID, ID) until 42;
                      while 'STRING' do ID;
                     ;
                      repeat while+ 42 do for ID:= true and 'STRING'+ true to true<= 42- false+ false do writeln(+ 3.14159 mod not not 42, not ID div 3.14159);
                      until not 'STRING'>- not false;
                     
                  end;
                  ;
                   ID;
                  ;
                   for ID:= 42 downto+ 42 div true< false do ID( 42<> 'STRING');
                  ;
                  ;
                  
                  begin
                      while false do read( ID);
                      read( ID, ID, ID);
                      writeln( true= not not false);
                     ;
                      if 'STRING' then ID;
                     ;
                      write( 'STRING' div not 3.14159, 'STRING', 3.14159> 3.14159, 'STRING',( ID mod 42)>=( 42 div( not( 42 or 'STRING'))))
                  end;
                  ;
                  
                  begin
                     ;
                     ;
                      read( ID)
                  end until 'STRING'>= true until 'STRING'
               end;
               ;
                repeat repeat for ID:= false<= 42 to+ true<=( false= 42) do until+ ID;
               ;
                if not(+ ID+( 42<>+(-(+( not false) or not 3.14159)= 42)/ ID))<=-( ID*( true)) then read( ID) else read( ID) until 'STRING'< false;
               ;
                for ID:= true or 3.14159 downto(- ID(- ID>=- 3.14159 or not(+ ID(+ 3.14159)),+ false* not 3.14159* 'STRING'/ ID/ 'STRING'))* not ID+ 42 do repeat writeln( 'STRING', 'STRING');
                repeat until not 'STRING' and true mod 3.14159= not 3.14159;
                write( false, not false and( 3.14159) div false, not not ID, true or ID);
                if(((+ false- not 'STRING'))) then else ID until true div false/ 42;
               ;
               
            end;
         
         function ID( ID: float): string;
            
            begin
                read( ID)
            end;
         
         procedure ID( ID, ID, ID: boolean);
             var ID: string;
            
            function ID: float;
                var ID: boolean;
               
               function ID: boolean;
                   var ID, ID: string;
                  
                  procedure ID( ID, ID, ID: string);
                     
                     begin
                        ;
                         write( 3.14159<> false, true)
                     end;
                  
                  begin
                      for ID:= true downto 'STRING'<>- 42 do while true do;
                      ID(+ 42, 'STRING'> false, 3.14159, 'STRING' or 42> not 42, not 'STRING' or 3.14159+ 42<> 42, 3.14159+ 42/ 'STRING' or ID<>+ false- true* 42);
                      if not not 3.14159 then repeat for ID:=+ 'STRING' div not 3.14159 mod 3.14159/ 3.14159 to ID+ true do until ID> 3.14159 and false
                  end;
               
               begin
                  ;
                  ;
                   repeat writeln( 42<> not not 3.14159, 42,-(- 3.14159* 3.14159)>- 3.14159, 3.14159>=- 'STRING');
                   ID until true=+ true;
                  ;
                   for ID:= true<> 42 downto 'STRING'<= 42 and(-( ID div 42)) do writeln( 42=+ ID and 'STRING', 'STRING'/ 42,( 42* true=(- 'STRING'/ 42 or not false<= 'STRING')+ ID) or 3.14159- true<> false, false>+ ID, not 42 div 'STRING'/ 3.14159 or false/ ID* not 42, false- true* 3.14159, 3.14159);
                   ID;
                   for ID:= 42 or 42> 3.14159+ 42 to false>= true+ 'STRING' do if false then write( not true<- ID and true, 42> false and 'STRING');
                  ;
                   write( 3.14159);
                  ;
                   for ID:= 42+( 3.14159) or 'STRING' mod 'STRING' mod 'STRING'* not true/ false or false mod true<> ID to 'STRING' do ID;
                   write( 42<> 3.14159);
                   ID;
                  ;
                  ;
                   repeat read( ID);
                  ;
                   if 3.14159 then for ID:= 3.14159 downto- not 3.14159 do repeat;
                  ;
                   until ID;
                  ;
                   read( ID);
                  ;
                   for ID:= 'STRING'- ID/ not 42=( 42) to false do while not not 42+( 3.14159)= ID do repeat write(+ true) until 'STRING'>= 'STRING';
                   while- 42 and false or 42 do while not 42 do ID;
                   read( ID);
                  ;
                  ;
                   read( ID, ID);
                   until true<= 42/ true;
                   ID
               end;
            
            procedure ID;
                var ID: float;
               
               begin
                  ;
                   write( ID, 42)
               end;
            
            begin
               ;
               ;
                write( true);
               ;
                writeln( ID+( false or false> ID), ID= ID,+ 'STRING');
                for ID:=(( true))> 3.14159 and 'STRING'* 'STRING' downto ID<> true do while 3.14159> false* ID do
            end;
         
         begin
             for ID:= ID and 42 to 3.14159 do;
             while 3.14159* 3.14159<=- false do;
            ;
             repeat if 3.14159 then
            begin
               
            end;
             read( ID);
            ;
             repeat writeln( 3.14159);
            
            begin
               ;
               
               begin
                   write( 'STRING' div not false, ID<=-( 3.14159>= not false), ID/ 3.14159,-(- 42), false div(- true) and 42 and false> false, false mod not false<=+ 'STRING')
               end
            end until not(- not 'STRING');
             ID;
             writeln( false> 'STRING', false<> true) until- 'STRING';
            ;
             if+ 3.14159 then if 'STRING' and 3.14159<= 3.14159 then if false and(( not( ID<+ false or true+ ID)>+ 3.14159- not( true)* true))* 3.14159 then while 'STRING'>= not 42 do for ID:=-( 3.14159+( ID)= true) to 'STRING'<= true do ID;
             for ID:= true<=+ 42 downto( 3.14159* 'STRING') or( not true and 3.14159 div ID) do if( 3.14159)- 'STRING' then ID;
             for ID:= true downto- not not not 42 do for ID:=- 3.14159 or 42/ not true>=+(- false* 42) mod( false<>(+ 3.14159< 42)) downto- 42> false do read( ID)
         end;
      
      begin
         ;
          if ID then;
          write( not ID( true* 3.14159=( 3.14159< not false)/ 42) and ID);
          write( 42<= true or ID);
         
      end;
   
   procedure ID;
      
      function ID( var ID: string): integer;
          var ID: integer;
         
         function ID: boolean;
             var ID, ID, ID: integer;
            
            function ID: float;
               
               procedure ID;
                  
                  begin
                      for ID:= ID- 42 downto-((- 42 or 'STRING') and 3.14159) do;
                     ;
                      writeln( true mod not false, 3.14159>= 3.14159/( 3.14159= ID/ 3.14159),( false), false, not( false)>= not 3.14159);
                     ;
                      while 'STRING' do;
                      ID
                  end;
               
               begin
                  ;
                  
               end;
            
            procedure ID;
                var ID: integer;
               
               begin
                   for ID:= 3.14159+ 3.14159- ID/ not 'STRING' to false do;
                   while 'STRING' and 3.14159 do for ID:= false to true and false<>+ 3.14159 do writeln(((( 'STRING'))= ID div false));
                  ;
                  ;
                  ;
                  ;
                   if true then;
                  ;
                   read( ID);
                   repeat;
                  ;
                   while 'STRING' do read( ID, ID);
                  ;
                  ;
                   repeat ID;
                  ;
                   repeat;
                  ;
                   ID;
                   for ID:=( true<> 3.14159+ 3.14159) to 3.14159/ true<= 42 or not true* 42/ 3.14159/( true)-( 42<>+ ID) do while false do;
                   writeln( not( 3.14159> 42)* ID<> 3.14159 or ID);
                   read( ID, ID);
                   repeat ID until 3.14159;
                   ID;
                   for ID:= ID/ true downto 'STRING'<= true do if not 'STRING'> 3.14159- not( false< 42+ true) then repeat writeln(-( false mod 3.14159 mod ID* ID)- 42);
                  ;
                  ;
                   read( ID, ID);
                   while 'STRING' div ID+ false> 42 do until 'STRING'> ID div true/ not 3.14159 or false until not not 'STRING'> 42 div not 'STRING'+ 'STRING' until not false until 3.14159
               end;
            
            begin
                repeat read( ID);
                repeat write(((( 42> false)< ID or 42)));
                ID;
                writeln((+(- ID))<= 3.14159);
                read( ID);
                read( ID, ID);
                read( ID, ID);
               
               begin
                   ID;
                   if true/ 42 then read( ID) else while 3.14159 do;
                  
               end;
               
               begin
                   for ID:= not ID<> ID to true do writeln( 3.14159-( ID* false)- 3.14159)
               end;
                if 'STRING' mod 3.14159 mod 42- 'STRING'>= 'STRING' then for ID:=- false downto( 3.14159)<=+ true do ID;
                writeln( not( false* 'STRING')>= ID) until not 3.14159/(- false)+ 42;
                read( ID, ID, ID);
               ;
                while 42>=- false and 'STRING' do
               begin
                   if( 3.14159* not 42 and 3.14159 div false mod false) then else write( 3.14159,+ not false> not 'STRING', 'STRING', 'STRING')
               end until- ID/ 3.14159<> not(+ not( 42* true<=- 42)* ID)/ 'STRING'
            end;
         
         function ID: boolean;
            
            function ID( var ID, ID: float): float;
               
               function ID: boolean;
                   var ID: integer;
                  
                  begin
                      write(( true/ not 42 div 'STRING' mod 42)>= 'STRING', false<> ID mod 42, true);
                      ID( 3.14159 and 42=( 42));
                     ;
                     ;
                     ;
                      if- false= false then;
                      while 42< ID do write(( 'STRING') div ID mod not false,- 42, 3.14159);
                     
                  end;
               
               begin
                  
               end;
            
            function ID: integer;
               
               begin
                   writeln(+ 3.14159=- 'STRING' or( false));
                  ;
                   while+ not 'STRING' do writeln( ID* 42);
                   while- not 'STRING' do read( ID, ID);
                   if not 42= true then while true=( 3.14159) or 42 mod not( 42) and 'STRING' do writeln(+ false, 3.14159<> 'STRING', not 'STRING'<>+ 3.14159);
                   ID;
                   while+ not 'STRING' and 3.14159 do;
                   while- 3.14159+ false do read( ID, ID)
               end;
            
            procedure ID;
               
               begin
                  ;
                  ;
                   for ID:= ID downto 3.14159/ 3.14159 do read( ID, ID, ID, ID, ID);
                   if true div false+ 3.14159 then;
                   repeat read( ID, ID, ID);
                   for ID:=+ ID/ false downto 3.14159 do;
                  ;
                   writeln(+ 'STRING'- 3.14159);
                   if 'STRING'= 'STRING' then;
                  ;
                  ;
                   if ID>= true or false then while ID*( not ID) do else while 42= false do repeat;
                   if+ 3.14159* not 'STRING' or 'STRING'= false then for ID:= 3.14159 to 'STRING' div false and 'STRING' do read( ID, ID, ID);
                  ;
                   read( ID);
                   for ID:=+ ID to 3.14159 do;
                   for ID:= 42+( true)/ 42 to ID( ID)<> ID do writeln(- 'STRING' or true);
                   if( 'STRING'<+ 'STRING'*( false* false+ 42>-( true))/ not 'STRING')- ID then if true div 'STRING'* 'STRING' then while not 3.14159 div true+ not false do repeat read( ID, ID) until not(- 'STRING'<=(- false>= not 'STRING'))> ID else if 42 div not not ID+ 3.14159 then;
                   for ID:= 42/ false downto 3.14159>= false do writeln( 'STRING');
                   for ID:= false to false< ID do repeat;
                   writeln( 42<=( true), true);
                  ;
                   write( not not 42>= false);
                   writeln( true and 'STRING');
                   while( false) do repeat;
                   for ID:=(+ 3.14159)<=+ not 42 downto 3.14159 or ID do write( false);
                  ;
                   writeln( ID<> not 'STRING' and ID( 3.14159>=- true)) until-(( 42)) and 42;
                   repeat read( ID, ID);
                  ;
                  ;
                   ID;
                   write(+ true<>- false);
                   write( not true or 42);
                   for ID:=- 3.14159* 'STRING' downto not 42- false do while ID mod ID- true and false/ true=+ true do;
                  ;
                   ID;
                  ;
                  ;
                   repeat while false and ID+(- 42<=(+ 3.14159>= ID( 'STRING'/ 'STRING',+ true= 'STRING' or 'STRING'))) do repeat repeat;
                   repeat repeat until+ not true/ 42<= 3.14159;
                  ;
                  ;
                   if 3.14159 then read( ID, ID) until false until- 'STRING'* not 3.14159;
                   repeat;
                  ;
                  ;
                   until+ true and true mod false;
                   repeat;
                   if 3.14159 then while 3.14159<+ true do for ID:= 'STRING' to 3.14159>= false div( ID) do repeat until true;
                   until 3.14159/ 'STRING'< false;
                  ;
                   repeat writeln( 42/ 'STRING', not 'STRING'/ not 42);
                   writeln( false);
                  ;
                   write( not not ID(+( ID))- false+ ID) until true<= 'STRING';
                   ID;
                   read( ID, ID);
                   for ID:= 'STRING' mod true or true downto 42 or 3.14159 do write( 3.14159>= 3.14159);
                   while 42+ false do;
                   write( true);
                   while true do;
                   writeln( 'STRING'- not( 3.14159 div true>= not false)<= not 'STRING',+ false);
                  ;
                  ;
                   write( 3.14159);
                   write((-( ID)));
                   write( ID mod 3.14159 and 42* 'STRING'* 3.14159> not 'STRING');
                   while not 42+( 42)> ID do write(( false*( ID and( true and 'STRING'<> not not true))- 'STRING')- 3.14159, ID/ true, ID mod 'STRING' or( 42), not not ID, 42);
                   for ID:= 42> 42 and 3.14159 to not false do read( ID);
                   writeln(( true div 42)<=( 3.14159 or 42<= false* 3.14159) mod false or not 'STRING', true+ 3.14159> 42+( true/ true), 'STRING'<> true+ 'STRING',( 3.14159*( 3.14159 and 3.14159))+ true<> not 'STRING') until ID;
                   until not false;
                  ;
                   read( ID);
                   until- 'STRING'<> 42;
                   if( ID<= true)> false mod( true=- true) and 3.14159 or ID then write( ID<=- true mod false) else until 3.14159<=( 'STRING' div 42> 3.14159* 3.14159)* not 42;
                  ;
                   repeat ID;
                   write( not false div 42, 42, 42<>(+ false< false div not( true) or ID));
                   repeat for ID:= 42 to 42- ID(( ID>=- 'STRING') and 'STRING'< 3.14159)* 42= ID do writeln(- 'STRING'< ID+ false div(( 42 and ID)<= not not 3.14159 div true div false or ID mod 3.14159),- false-(( false) div ID>+ not 3.14159 mod 42));
                   writeln( 42, 'STRING');
                  ;
                  ;
                   while+ 'STRING'<= false and 3.14159 do read( ID);
                  ;
                   read( ID);
                  ;
                   while+(-( 42= not not 42+( not ID div 'STRING') and( ID* ID))- 'STRING' or true or 'STRING'>= ID/( 'STRING'))<= 42 do while false and true do;
                   while+ 3.14159- 'STRING' do for ID:=( not not( 'STRING'- ID>= 3.14159)) to not true do;
                   repeat ID;
                  ;
                   if+ 42<> ID then;
                  ;
                   writeln(- ID+ ID);
                  ;
                   repeat;
                   until- 3.14159;
                  ;
                   writeln( 3.14159<> false);
                   writeln( ID< 3.14159 and(- true), 42);
                   while+ false<(- ID<> not true) do writeln( true<= 'STRING' mod(( true- ID*(+ not( 42))*(- not true< 'STRING'))* false),((+ not true)/ not not true+ ID- 'STRING'));
                   read( ID, ID);
                   repeat read( ID);
                  ;
                   write( true, 42<> 3.14159- false, not 3.14159 or 3.14159);
                   for ID:= not 42 or ID downto ID( 42, false mod not true* 'STRING' or 3.14159, true/ true, 42, 42 div 42/ ID* true< 42) and ID or( true<( 3.14159 mod 'STRING'>=( not 3.14159<= 3.14159))) div 3.14159- not 42<( true> not(- 'STRING')- true* not not 3.14159) do repeat repeat;
                  ;
                   read( ID, ID);
                   repeat;
                   writeln( ID- 3.14159, ID( true), 42 or false* 3.14159 and ID);
                   write(- 'STRING');
                   repeat if not false< 3.14159 then;
                  ;
                  ;
                   for ID:=- not 3.14159 or(( 'STRING')< 42) mod false mod not false= false+ true downto not 'STRING' do;
                   while+ 42 do repeat while+ 'STRING'>= true do for ID:= ID>= 42 to( 'STRING'>= 'STRING') do for ID:= not false=+ 3.14159 to false>= false do repeat while ID do write(+ not false>= 42 mod 'STRING');
                   repeat repeat ID;
                  ;
                  ;
                   repeat for ID:= not ID- 'STRING'>+ 42 downto not not false div true do if ID<>- false then;
                   writeln( 'STRING' or( not 'STRING')* 42 mod 42, true,- not ID= ID, false and 'STRING'<= false div( false<= 42 mod true) mod( not 42= 'STRING' and 'STRING'),(( 'STRING' and 42- ID) div 3.14159+ not 'STRING'));
                   for ID:= false mod ID downto+ 42 div false do for ID:=( true/ 3.14159)<> not true+ not not 'STRING' downto 3.14159 do repeat;
                  ;
                  ;
                   ID;
                   read( ID, ID, ID);
                   write( false, ID< 'STRING' div ID);
                   read( ID, ID, ID, ID);
                   ID;
                  ;
                   while false<+( false> ID) do;
                  ;
                   until(( true or 3.14159> 'STRING'- false));
                   until((- 3.14159-( 'STRING'> 42))<>((+ not true<=- not not true)/ not ID<>+ true)) or 'STRING';
                   repeat if 42>= ID then for ID:= not ID to 42 mod ID> ID/ true do write( true, 42/ 42/ true);
                  ;
                   while+ ID do for ID:=+ true- 3.14159 downto(( ID=(-( true)))<( ID= ID)) do;
                   ID until( 3.14159)- ID until 3.14159 until- true<= 3.14159 mod 42;
                   for ID:= false>= 'STRING' to( 3.14159)+ 42* not(+( not ID) mod true mod false) do while not( 'STRING')<> 'STRING' do write( 'STRING');
                   writeln( not 'STRING'+ not not 42);
                   if not true>= true/ not not(( 'STRING' or 'STRING' and( false>=(- not ID<= 3.14159))>= false+ 3.14159) div( true and true mod not 42+ true)>+ 3.14159/ 3.14159 or 3.14159+( not 3.14159)) then writeln( 42<>(+ false mod ID or ID div false) or true, not 'STRING'- 3.14159 div true/ false<= ID,+ ID);
                   writeln( ID);
                  ;
                   write( 3.14159 and 3.14159, not 42< 'STRING',- 'STRING',(( 'STRING' div 3.14159*( false or 3.14159)) div 42/ 42<= 'STRING'* 'STRING') or ID- false<=+ 3.14159) until ID- ID;
                   writeln( ID>(+ 3.14159), not 'STRING', ID<= true);
                  ;
                   if true-( false and 'STRING'= 42 mod( 42<= true)) then;
                   ID( 'STRING' div ID mod ID);
                  ;
                  ;
                   until 'STRING';
                  ;
                   write(+ true div ID or ID( 'STRING' div 'STRING'<= not true, 42, ID)) until 42>= true and true* 3.14159;
                   ID;
                   read( ID);
                  ;
                   if 42<> 42 then if false then write(- false and false= 42) until ID;
                  ;
                   write(( true= not 42)*( 42)>= not( true mod 'STRING'<( false* 'STRING'-(- false)> true)),( 'STRING')<=( true> true)) until false/ true;
                  ;
                   until+ ID;
                   ID;
                   writeln( true< not ID);
                   if- 'STRING'* true then ID;
                   writeln(- 'STRING', true);
                  ;
                  ;
                   if false>= ID/ not 3.14159 then read( ID, ID, ID, ID) else writeln( 42/ 42);
                  ;
                  ;
                   for ID:= ID downto true<> 'STRING' do;
                  ;
                   writeln(((- 42))- false* 42 div 3.14159);
                  ;
                  ;
                  ;
                  ;
                   until not 42;
                  ;
                   until- 'STRING';
                   repeat until not ID until( 'STRING');
                  ;
                   writeln( ID+ 42>(+ 'STRING' div( 3.14159)<>( ID)* 'STRING') or false,+ 3.14159> not ID or true, 42- true= not 42/ 'STRING' and( ID), 3.14159>=+ 3.14159, 3.14159) until 3.14159+ ID* 'STRING' until 'STRING'/ 42 until 'STRING' mod(+ ID or false/ 3.14159);
                  
               end;
            
            begin
                write( true);
                if false< not 42 then for ID:=(( 3.14159)= true)= 'STRING' downto- false do repeat;
                write( 3.14159=+ 42 or 42, 3.14159= 'STRING', 'STRING'< 3.14159 mod 'STRING' div 'STRING', 42, false<=(( 42)<>(- ID and not( 3.14159<= false)+ ID)));
                while not 42 or( false) do while( false)/ ID do write( false, true* true- false, 42);
               ;
               ;
                writeln( ID);
                write(- true* ID* not false div( 42<=+ false+ ID) mod false);
                read( ID, ID, ID) until(( 'STRING'=( false<> 42)))/(( 3.14159> 3.14159 or true)<- ID)+ false/ ID;
               
            end;
         
         begin
            ;
            ;
            ;
            ;
             for ID:= ID or not true or 42<> false downto 'STRING' do;
             while not not 'STRING' do repeat read( ID);
            ;
             write(( true< 42));
             for ID:= not not 42 div false* true/ not 3.14159 to 'STRING' do;
             if- false then else;
             until false> 3.14159;
             write( 3.14159 mod(( true/ 3.14159)));
             read( ID);
             for ID:= 'STRING'* ID to 3.14159 do;
             while- 3.14159 do;
             while 3.14159 do write( not 42<=( 42+ ID<>( 3.14159)/ 3.14159));
            ;
            ;
             for ID:= 42= true to 'STRING'+(+ 'STRING')< 3.14159 do
         end;
      
      procedure ID;
          var ID: float;
         
         begin
             for ID:= 'STRING'+ true mod( 3.14159)/ false to(- not ID)<>( ID) do;
             repeat ID;
             repeat;
             if true< 'STRING' and ID+ not 'STRING' then;
             ID;
            ;
            ;
            ;
             ID;
             if not false div 3.14159/ 'STRING' then if ID then read( ID, ID, ID) until 'STRING' mod ID;
             while true do ID;
             write(- true);
            ;
             write( ID, ID>= ID div false- not 42 div false) until true;
            ;
            ;
            ;
            ;
             for ID:=( 42) mod 42 downto 42 do;
            
         end;
      
      procedure ID;
          var ID: integer;
         
         procedure ID;
             var ID: float;
            
            begin
                write( 3.14159- 42 and false+ 'STRING' or 3.14159);
                write( 3.14159);
               
            end;
         
         begin
            ;
             ID
         end;
      
      begin
         
         begin
             ID
         end;
         ;
          repeat writeln( false+( 3.14159)+ 42, false+ 3.14159,+ not false);
          write( 3.14159= 3.14159, 3.14159=(- 42 and 'STRING'), true and(+ not ID), false and 'STRING' and ID);
          until ID
      end;
   
   begin
       while ID mod false div(( 42)< 'STRING') or(( ID( 'STRING', false,( 42/ 42<= ID+ 3.14159)+ 'STRING' mod 3.14159/ false,+( true)*( ID<= false* 'STRING' div false/ 'STRING'+ 42/ false- false), not( false)<= true)- not 42)) do writeln(+( not false));
       if 42= 3.14159 then
      begin
          for ID:=(( false)) downto false do while false div not false do for ID:=- 'STRING'>= false downto 42<= 3.14159 do;
          writeln(( not false)/ 'STRING'>+ 'STRING'* true, true)
      end;
       writeln((( 3.14159)));
       ID
   end.